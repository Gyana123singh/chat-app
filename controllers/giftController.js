const cloudinary = require("../config/cloudinary");
const User = require("../models/users");
const Category = require("../models/category");
const Room = require("../models/room");
const Gift = require("../models/gifts");
const GiftTransaction = require("../models/giftTransaction");

exports.addGift = async (req, res) => {
  try {
    const { name, price, category } = req.body;

    // ‚ùå Validation
    if (!name || !price || !category || !req.file) {
      return res.status(400).json({
        success: false,
        message: "Name, price, category and image are required",
      });
    }

    // ‚úÖ Upload image to Cloudinary
    const uploadResult = await cloudinary.uploader.upload(req.file.path, {
      folder: "gifts",
      resource_type: "image",
    });

    // ‚úÖ Save gift
    const gift = await Gift.create({
      name,
      price,
      category,

      // üî• IMPORTANT PART
      giftImage: uploadResult.secure_url, // ‚úÖ MAIN IMAGE
      cloudinaryId: uploadResult.public_id,

      mediaType: uploadResult.format === "gif" ? "gif" : "image",
    });

    return res.status(201).json({
      success: true,
      message: "Gift added successfully",
      gift,
    });
  } catch (error) {
    console.error("Add Gift Error:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
};

exports.addCategory = async (req, res) => {
  try {
    const { name } = req.body;

    // ‚úÖ Validation
    if (!name || !name.trim()) {
      return res.status(400).json({
        message: "Category name is required",
      });
    }

    // ‚úÖ Check duplicate
    const exists = await Category.findOne({ name: name.trim() });
    if (exists) {
      return res.status(409).json({
        message: "Category already exists",
      });
    }

    // ‚úÖ Create category
    const category = await Category.create({
      name: name.trim(),
    });

    return res.status(201).json({
      message: "Category added successfully",
      category,
    });
  } catch (error) {
    console.error("Add Category Error:", error);
    return res.status(500).json({
      message: "Internal server error",
    });
  }
};
exports.getCategory = async (req, res) => {
  try {
    const categories = await Category.find().sort({ createdAt: -1 }); // ‚úÖ OLD ‚Üí NEW (new data at bottom)

    return res.status(200).json({
      success: true,
      count: categories.length,
      categories,
    });
  } catch (error) {
    console.error("Get Category Error:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
};

exports.getAllGifts = async (req, res) => {
  try {
    const { category, page = 1, limit = 20 } = req.query;

    // ‚úÖ FIX 1: correct field name
    let query = { isAvailable: true };

    // ‚úÖ FIX 2: category filter (ObjectId-safe)
    if (category) {
      query.category = category;
    }

    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const skip = (pageNum - 1) * limitNum;

    // ‚úÖ FIX 3: populate category name
    const gifts = await Gift.find(query)
      .populate("category", "name") // üî• IMPORTANT
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limitNum);

    const total = await Gift.countDocuments(query);

    return res.status(200).json({
      success: true,
      gifts,
      pagination: {
        total,
        page: pageNum,
        pages: Math.ceil(total / limitNum),
      },
    });
  } catch (error) {
    console.error("Get All Gifts Error:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to fetch gifts",
    });
  }
};

exports.checkEligibility = async (req, res) => {
  try {
    const { giftId, recipientId } = req.body;
    const userId = req.user.id;

    const user = await User.findById(userId);
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found", eligible: false });
    }

    const gift = await Gift.findOne({ giftId, isActive: true });
    if (!gift) {
      return res
        .status(404)
        .json({ success: false, message: "Gift not found", eligible: false });
    }

    const eligible = user.coinBalance >= gift.coinCost;

    return res.json({
      success: true,
      eligible,
      userCoins: user.coinBalance,
      giftCost: gift.coinCost,
      giftName: gift.giftName,
      message: eligible
        ? "Sufficient balance"
        : `Need ${gift.coinCost - user.coinBalance} more coins`,
    });
  } catch (error) {
    next(error);
  }
};

exports.sendGift = async ({
  senderId,
  roomId,
  giftId,
  targetType, // single | all | mic
  targetUserId,
  micUsers = [],
  roomUsers = [],
}) => {
  // 1Ô∏è‚É£ Gift validation
  const gift = await Gift.findById(giftId);
  if (!gift || !gift.isAvailable) {
    throw new Error("Gift not available");
  }

  // 2Ô∏è‚É£ Sender wallet
  const sender = await User.findById(senderId);
  if (!sender) throw new Error("Sender not found");

  // 3Ô∏è‚É£ Decide receivers
  let receivers = [];

  if (targetType === "single") {
    receivers = [targetUserId];
  }

  if (targetType === "all") {
    receivers = roomUsers;
  }

  if (targetType === "mic") {
    receivers = micUsers;
  }

  if (!receivers.length) {
    throw new Error("No receivers found");
  }

  // 4Ô∏è‚É£ Calculate total cost
  const totalCost = gift.price * receivers.length;

  if (sender.coins < totalCost) {
    throw new Error("Insufficient coins");
  }

  // 5Ô∏è‚É£ Deduct sender coins
  sender.coins -= totalCost;
  await sender.save();

  // 6Ô∏è‚É£ Credit receivers & store transactions
  const transactions = [];

  for (const receiverId of receivers) {
    await User.findByIdAndUpdate(receiverId, {
      $inc: { coins: gift.price },
    });

    transactions.push({
      roomId,
      senderId,
      receiverId,
      giftId: gift._id,
      giftIcon: gift.icon,
      giftPrice: gift.price,
      giftCategory: gift.category,
      giftRarity: gift.rarity,
    });
  }

  await GiftTransaction.insertMany(transactions);

  return {
    gift,
    receivers,
    totalCost,
    senderBalance: sender.coins,
  };
};
